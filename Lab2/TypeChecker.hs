module SkelCPP where
 --(PDefs [(DFun Type_bool (Id "Main") [] [(SReturn (EInt 1))] ),(DFun Type_int (Id "iain") [] [(SReturn ETrue)] ),(DFun Type_int (Id "nain") [] [(SReturn ETrue)] )] )
-- [(SExp ETrue) ,(SReturn ETrue),(SWhile ETrue (SReturn ETrue)),(SBlock [(SReturn ETrue),(SReturn ETrue)]),(SIfElse ETrue (SReturn ETrue) (SReturn ETrue))]
-- Haskell module generated by the BNF converter

import AbsCPP
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transId :: Id -> Result 
transId (Id (x:xs))
    | (x `elem` ['A'..'Z']) = (Bad $ "Starts with uppercase letter")
    | (x `elem` ['0'..'9']) = (Bad $ "Contains a number")
    | ([y| y <- (['A'..'Z']++['a'..'z']++['1'..'9']++['_']), y `elem` xs] == xs) = (Ok (x:xs))
    | otherwise = failure (x:xs)

transProgram :: Program -> Result ---no duplicated function names !+ has a main
transProgram (PDefs (def:[])) = transDef(def)
transProgram (PDefs (def:defs)) 
    | (helpProgram((def:defs))) = case transDef(def) of 
                                    (Bad _) -> (failure $ transDef(def))
                                    (Ok _) -> transProgram((PDefs defs))
    | otherwise = Bad "Duplicate function names found" 

helpProgram :: [Def] -> Bool
helpProgram def = helpProgram2([(\(DFun _ (Id i) _ _) -> i) x|x <- def ])

helpProgram2 :: [String] -> Bool 
helpProgram2 (x:xs) = ( not (x `elem` xs)) &&  helpProgram2(xs)
helpProgram2 [] = True

transDef :: Def -> Result -- must contain return statemen
transDef (DFun t a b (s:st))  
    | (helpDef2 t (helpDef(s:st))) = helpDef3(s:st)
    | otherwise = Bad (show (s:st))

----
helpDef :: [Stm] -> [Stm]
helpDef (x:xs) = case x of 
  (SReturn _) -> [x] ++ helpDef(xs)
  (SBlock y) -> helpDef(y) ++ helpDef(xs)
  (SIfElse _ y z) -> helpDef([y]) ++ helpDef([z]) ++ helpDef(xs)
  otherwise -> helpDef(xs)
helpDef [] = []

helpDef2 :: Type -> [Stm] -> Bool
helpDef2 t lst = ([y | y <- [expToType ((\(SReturn x) -> x) x)| x <-lst] , y /= t ]  == [])

helpDef3 :: [Stm] -> Result 
helpDef3 [] = Ok "Pass all statements"
helpDef3 (s:st) = case transStm(s) of
          (Bad a) -> Bad $ a ++ " in " ++ show s
          (Ok _) -> helpDef3(st)
----


transArg :: Arg -> Result
transArg x = case x of
  ADecl type' id -> Ok (show x)   
  otherwise -> failure x


transStm :: Stm -> Result
transStm x = case x of
  SExp _exp  -> transExp(_exp)
  SDecls type' ids  -> transExp(_exp)
  SInit type' id _exp  -> transExp(_exp)
  SReturn _exp  -> transExp(_exp)
  SWhile _exp stm  -> transExp(_exp)
  SBlock stms  -> transExp(_exp)
  SIfElse _exp stm1 stm2  -> transExp(_exp)

expToType :: Exp -> Type
expToType x = case x of
  ETrue  ->  Type_bool
  EFalse  -> Type_bool
  EInt n  -> Type_int
  EDouble d  -> Type_double



transType :: Type -> Result
transType x = 
  case x of
  Type_bool  -> failure x
  Type_int  -> failure x
  Type_double  -> failure x
  Type_void  -> failure x

transExp :: Exp -> Result
transExp x = case x of
  ETrue  -> Ok ""
  EFalse  -> Ok ""
  EInt n  -> Ok "" 
  EDouble d  -> Ok ""
  ETimes _exp1 _exp2  -> failure x -- int,doubles
  EDiv _exp1 _exp2  -> failure x -- int,doubles
  EPlus _exp1 _exp2  -> failure x -- int,doubles
  EMinus _exp1 _exp2  -> failure x -- int,doubles
  ELt _exp1 _exp2  -> failure x -- int,doubles
  EGt _exp1 _exp2  -> failure x -- int,doubles
  ELtEq _exp1 _exp2  -> failure x -- int,doubles
  EGtWq _exp1 _exp2  -> failure x -- int,doubles

  EEq _exp1 _exp2  -> failure x --- Bool
  ENEq _exp1 _exp2  -> failure x --- Bool
  EAnd _exp1 _exp2  -> failure x --- Bool
  EOr _exp1 _exp2  -> failure x -- Bool
  EAss _exp1 _exp2  -> failure x

check_int :: Exp -> Bool
check_int  ex = case ex of 
                    EInt n  -> True 
                    EDouble d  -> True
                    EApp _id _exps  -> check_int(_exps)
                    EPIncr _exp  -> check_int(_exps)
                    EPDecr _exp  -> check_int(_exps)
                    EIncr _exp  -> check_int(_exps)
                    EDecr _exp  -> check_int(_exps)
                    ETimes _exp1 _exp2  -> check_int(_exp1) && check_int(_exps2)
                    EDiv _exp1 _exp2  -> check_int(_exp1) && check_int(_exps2)
                    EPlus _exp1 _exp2  -> check_int(_exp1) && check_int(_exps2)
                    EMinus _exp1 _exp2  -> check_int(_exp1) && check_int(_exps2)
                    ELt _exp1 _exp2  -> check_int(_exp1) && check_int(_exps2)
                    EGt _exp1 _exp2  -> check_int(_exp1) && check_int(_exps2)
                    ELtEq _exp1 _exp2  -> check_int(_exp1) && check_int(_exps2)
                    EGtWq _exp1 _exp2  -> check_int(_exp1) && check_int(_exps2)
                    otherwise -> False  





