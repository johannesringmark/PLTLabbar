module SkelCPP where

-- Haskell module generated by the BNF converter

import AbsCPP
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transId :: Id -> Result 
transId (Id (x:xs))
    | (x `elem` ['A'..'Z']) = (Bad $ "Starts with uppercase letter")
    | ([y| y <- ['1'..'9'], y `elem` (x:xs)] /= []) = (Bad $ "Contains a number")
    | ([y| y <- (['A'..'Z']++['a'..'z']++['1'..'9']), y `elem` xs] == xs) = (Ok (x:xs))
    | otherwise = failure (x:xs)

transProgram :: Program -> Result ---no duplicated function names
transProgram (PDefs (def:defs))
    | ("main" `elem` [(\ (DFun x (Id y) z w) -> y) x | x <- (def:defs)])  = (Ok "Contains main") --example
    | otherwise = failure (def:defs)



transDef :: Def -> Result -- must contain return statemen
transDef (defs)
    | ((\(DFun x y z w) -> (x `elem` [(expToType(([(\ (SReturn c) -> c )t | t <- w, (case t of (SReturn i) -> True
                                                                                               _ -> False
                                                                                               )]!! 0)))] ))  defs) 
    = (Ok "Contains main")



transArg :: Arg -> Result
transArg x = case x of
  ADecl type' id  -> failure x


transStm :: Stm -> Result
transStm x = case x of
  SExp exp   -> failure x
  SDecls type' ids  -> failure x
  SInit type' id exp  -> failure x
  SReturn exp  -> failure x
  SWhile exp stm  -> failure x
  SBlock stms  -> failure x
  SIfElse exp stm1 stm2  -> failure x


transExp :: Exp -> Result
transExp x = case x of
  ETrue  -> failure x
  EFalse  -> failure x
  EInt n  -> failure x
  EDouble d  -> failure x
  EId id  -> failure x
  EApp id exps  -> failure x
  EPIncr exp  -> failure x
  EPDecr exp  -> failure x
  EIncr exp  -> failure x
  EDecr exp  -> failure x
  ETimes exp1 exp2  -> failure x
  EDiv exp1 exp2  -> failure x
  EPlus exp1 exp2  -> failure x
  EMinus exp1 exp2  -> failure x
  ELt exp1 exp2  -> failure x
  EGt exp1 exp2  -> failure x
  ELtEq exp1 exp2  -> failure x
  EGtWq exp1 exp2  -> failure x
  EEq exp1 exp2  -> failure x
  ENEq exp1 exp2  -> failure x
  EAnd exp1 exp2  -> failure x
  EOr exp1 exp2  -> failure x
  EAss exp1 exp2  -> failure x


transType :: Type -> Result
transType x = 
  case x of
  Type_bool  -> failure x
  Type_int  -> failure x
  Type_double  -> failure x
  Type_void  -> failure x

expToType :: Exp -> Type
expToType x = case x of
  ETrue  -> Type_bool
  EFalse  -> Type_bool
  EInt n  -> Type_int
  EDouble d  -> Type_double